from pythogic.ltlf.semantics.FiniteTrace import FiniteTrace
from pythogic.misc.Alphabet import Alphabet
from pythogic.misc.FormalSystem import FormalSystem
from pythogic.pl.PL import PL
from pythogic.pl.semantics.PLInterpretation import PLInterpretation
from pythogic.pl.syntax.PLFormula import PLFormula
from pythogic.ref.syntax.REfFormula import REfFormula, REfPropositionalFormula, REfUnion, REfSequence, REfStar


class REf(FormalSystem):
    def __init__(self, alphabet: Alphabet):
        super().__init__(alphabet)


    def _is_formula(self, f: REfFormula):
        """Check if a formula is legal in the current formal system"""
        if isinstance(f, REfPropositionalFormula):
            return all(s in self.alphabet.symbols for s in f.symbols)
        elif isinstance(f, REfUnion) or isinstance(f, REfSequence):
            return self._is_formula(f.f1) and self._is_formula(f.f2)
        elif isinstance(f, REfStar):
            return self._is_formula(f.f)
        else:
            raise ValueError("Argument not a valid Formula")

    def truth(self, trace: FiniteTrace, start: int, end: int, formula: REfFormula):
        assert self._is_formula(formula)
        assert trace.alphabet == self.alphabet
        truth = self.truth
        if isinstance(formula, PLFormula):
            symbol2truth = {e:True if e in trace.get(start) else False for e in self.alphabet}
            I = PLInterpretation(self.alphabet, symbol2truth)
            pl = PL(self.alphabet)
            return end == start + 1 and end < trace.length() and pl.truth(I, formula)
        elif isinstance(formula, Not):
            return not truth(trace, position, formula.f)
        elif isinstance(formula, And):
            return truth(trace, position, formula.f1) and truth(trace, position, formula.f2)
        elif isinstance(formula, Next):
            return position < trace.last() and truth(trace, position + 1, formula.f)
        elif isinstance(formula, Until):
            return any(
                truth(trace, j, formula.f2)
                and all(
                    truth(trace, k, formula.f1) for k in range(position, j)
                )
                for j in range(position, trace.last() + 1)
            )
        elif isinstance(formula, DerivedLTLfFormula):
            return truth(trace, position, formula._equivalent_formula())
        else:
            raise ValueError("Not valid formula")
